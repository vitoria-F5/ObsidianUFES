/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => EnhancedSymbolsPrettifier
});
module.exports = __toCommonJS(main_exports);
var import_obsidian2 = require("obsidian");

// src/search.ts
var SearchCursor = class {
  constructor(text, regex, _originalCaret) {
    this.text = text;
    this._originalCaret = _originalCaret;
    if (regex instanceof RegExp) {
      this.regex = regex;
    } else {
      this.regex = new RegExp(regex);
    }
    this.reset();
  }
  reset() {
    this._from = this._originalCaret;
    this._to = this._originalCaret;
    this._caret = this._originalCaret;
  }
  findNext() {
    const text = this.text.slice(this._caret);
    const match = text.match(this.regex);
    if ((match == null ? void 0 : match.index) == null) {
      return void 0;
    }
    if (match.length === 4) {
      this._from = this._caret + match.index + match[1].length;
      this._to = this._caret + match.index + match[1].length + match[2].length;
      this._caret = this._to;
      return match;
    }
    this._from = this._caret + match.index;
    this._to = this._caret + match.index + match[0].length;
    this._caret = this._to;
    return match;
  }
  to() {
    return this._to;
  }
  from() {
    return this._from;
  }
};

// src/settings/defaultSettings.ts
var FLEXIBLE_WORDS_START = ["(", "\xAB", "'", '"', "*"];
var FLEXIBLE_WORDS_END = [
  ".",
  ",",
  "!",
  "?",
  ":",
  ";",
  ")",
  "\xBB",
  "'",
  '"',
  "Enter",
  "\n",
  "*"
];
var DEFAULT_SETTINGS = {
  replacements: {
    "->": {
      replaced: "->",
      value: "\u2192",
      group: "Arrows"
    },
    "<-": {
      replaced: "<-",
      value: "\u2190",
      group: "Arrows"
    },
    "<->": {
      replaced: "<->",
      value: "\u2194",
      group: "Arrows"
    },
    "<=>": {
      replaced: "<=>",
      value: "\u21D4",
      group: "Arrows"
    },
    "=": {
      replaced: "<=",
      value: "\u21D0",
      group: "Arrows"
    },
    "=>": {
      replaced: "=>",
      value: "\u21D2",
      group: "Arrows"
    },
    "=/=": {
      replaced: "=/=",
      value: "\u2260",
      group: "Mathematical Operators"
    },
    "~=": {
      replaced: "~=",
      value: "\u2248",
      group: "Mathematical Operators"
    },
    "----": {
      replaced: "----",
      value: "\u2014",
      group: "Miscellaneous"
    },
    "(c)": {
      replaced: "(c)",
      value: "\xA9",
      group: "Miscellaneous"
    },
    "(r)": {
      replaced: "(r)",
      value: "\xAE",
      group: "Miscellaneous"
    },
    "/!\\": {
      replaced: "/!\\",
      value: "\u26A0",
      group: "Miscellaneous"
    },
    "(1)": {
      replaced: "(1)",
      value: "1\uFE0F\u20E3",
      group: "Numbers"
    },
    "(2)": {
      replaced: "(2)",
      value: "2\uFE0F\u20E3",
      group: "Numbers"
    },
    "(3)": {
      replaced: "(3)",
      value: "3\uFE0F\u20E3",
      group: "Numbers"
    },
    "(4)": {
      replaced: "(4)",
      value: "4\uFE0F\u20E3",
      group: "Numbers"
    },
    "(5)": {
      replaced: "(5)",
      value: "5\uFE0F\u20E3",
      group: "Numbers"
    },
    "(6)": {
      replaced: "(6)",
      value: "6\uFE0F\u20E3",
      group: "Numbers"
    },
    "(7)": {
      replaced: "(7)",
      value: "7\uFE0F\u20E3",
      group: "Numbers"
    },
    "(8)": {
      replaced: "(8)",
      value: "8\uFE0F\u20E3",
      group: "Numbers"
    },
    "(9)": {
      replaced: "(9)",
      value: "9\uFE0F\u20E3",
      group: "Numbers"
    },
    "(10)": {
      replaced: "(10)",
      value: "\u{1F51F}",
      group: "Numbers"
    },
    "(0)": {
      replaced: "(0)",
      value: "0\uFE0F\u20E3",
      group: "Numbers"
    },
    "w/": {
      replaced: "w/",
      value: "with",
      group: "Words"
    },
    "w/o": {
      replaced: "w/o",
      value: "without",
      group: "Words"
    },
    "->>": {
      replaced: "->>",
      value: "\u21C9",
      group: "Arrows"
    },
    "<<-": {
      replaced: "<<-",
      value: "\u21C7",
      group: "Arrows"
    },
    "=>>": {
      replaced: "=>>",
      value: "\u21C9",
      group: "Arrows"
    },
    "<<=": {
      replaced: "<<=",
      value: "\u21C7",
      group: "Arrows"
    },
    "===": {
      replaced: "===",
      value: "\u2261",
      group: "Mathematical Operators"
    },
    "!=": {
      replaced: "!=",
      value: "\u2260",
      group: "Mathematical Operators"
    },
    "=<": {
      replaced: "=<",
      value: "\u2264",
      group: "Mathematical Operators"
    },
    ">=": {
      replaced: ">=",
      value: "\u2265",
      group: "Mathematical Operators"
    },
    "<<": {
      replaced: "<<",
      value: "\u226A",
      group: "Mathematical Operators"
    },
    ">>": {
      replaced: ">>",
      value: "\u226B",
      group: "Mathematical Operators"
    },
    "||": {
      replaced: "||",
      value: "\u2225",
      group: "Mathematical Operators"
    },
    "&&": {
      replaced: "&&",
      value: "\u2227",
      group: "Mathematical Operators"
    },
    "+/-": {
      replaced: "+/-",
      value: "\xB1",
      group: "Mathematical Operators"
    },
    "...": {
      replaced: "...",
      value: "\u2026",
      group: "Miscellaneous"
    },
    sqrt: {
      replaced: "sqrt",
      value: "\u221A",
      group: "Mathematical Operators"
    },
    pi: {
      replaced: "pi",
      value: "\u03C0",
      group: "Mathematical Operators"
    },
    inf: {
      replaced: "inf",
      value: "\u221E",
      group: "Mathematical Operators"
    },
    sum: {
      replaced: "sum",
      value: "\u2211",
      group: "Mathematical Operators"
    },
    prod: {
      replaced: "prod",
      value: "\u220F",
      group: "Mathematical Operators"
    },
    delta: {
      replaced: "delta",
      value: "\u0394",
      group: "Greek Letters"
    },
    alpha: {
      replaced: "alpha",
      value: "\u03B1",
      group: "Greek Letters"
    },
    beta: {
      replaced: "beta",
      value: "\u03B2",
      group: "Greek Letters"
    },
    gamma: {
      replaced: "gamma",
      value: "\u03B3",
      group: "Greek Letters"
    },
    epsilon: {
      replaced: "epsilon",
      value: "\u03B5",
      group: "Greek Letters"
    }
  },
  exclusions: [],
  flexibleWordsStart: true,
  flexibleWordsEnd: true
};

// src/settings/settings.ts
var import_obsidian = require("obsidian");

// src/settings/DataExport.ts
var DataMapper = class {
  constructor(settings) {
    this.settings = settings;
  }
  exportGroup(group) {
    const exportData = {};
    Object.keys(this.settings.replacements).forEach((key) => {
      const replacement = this.settings.replacements[key];
      if (group === "all" || replacement.group === group) {
        exportData[key] = __spreadValues({}, replacement);
        delete exportData[key].count;
        delete exportData[key].disabled;
      }
    });
    const blob = new Blob([JSON.stringify(exportData)], {
      type: "application/json"
    });
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    const groupFilename = group.replace(/[^a-z0-9]/gi, "-").toLowerCase();
    const date = new Date().toISOString().split("T")[0];
    a.download = `enhanced-symbols-prettifier-${groupFilename}-export-${date}.json`;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
  }
};

// src/finder/ShortcutsFinder.ts
var ShortcutsFinder = class {
  constructor(plugin, excluded_shortcuts = [], excluded_words = []) {
    this.top_words = {};
    this.suggested_shortcuts = {};
    this.excluded_shortcuts = [];
    this.excluded_words = [];
    this.plugin = plugin;
    this.excluded_shortcuts = excluded_shortcuts;
    this.excluded_words = excluded_words;
  }
  findShortcuts() {
    return __async(this, null, function* () {
      yield this.fetchDocuments();
      return this.findSuggestedShortcuts();
    });
  }
  findSuggestedShortcuts() {
    Object.keys(this.top_words).forEach((word) => {
      const shortcut = this.findShortcutAssociated(word);
      if (!this.suggested_shortcuts[shortcut]) {
        this.suggested_shortcuts[shortcut] = {};
      }
      this.suggested_shortcuts[shortcut][word] = this.top_words[word];
    });
    Object.keys(this.suggested_shortcuts).forEach((shortcut) => {
      const words = this.suggested_shortcuts[shortcut];
      const maxWord = Object.keys(words).reduce(
        (a, b) => words[a] > words[b] ? a : b
      );
      this.suggested_shortcuts[shortcut] = { [maxWord]: words[maxWord] };
    });
    this.excluded_shortcuts.forEach((shortcut) => {
      if (this.suggested_shortcuts[shortcut]) {
        delete this.suggested_shortcuts[shortcut];
      }
    });
    return this.suggested_shortcuts;
  }
  findShortcutAssociated(word) {
    if (word.length == 4) {
      return word[0] + word[3];
    }
    word = word.replace(/[^a-zA-ZÀ-ÿ]/g, "");
    const consonants = word.match(/[^aeiou]/g);
    if (consonants && consonants.length >= 3) {
      return consonants.slice(0, 3).join("");
    }
    return word.slice(0, 3);
  }
  fetchDocuments() {
    return __async(this, null, function* () {
      const files = this.plugin.app.vault.getMarkdownFiles();
      const documents = yield Promise.all(
        files.map((file) => this.plugin.app.vault.cachedRead(file))
      );
      this.findTopWords(documents);
    });
  }
  findTopWords(documents) {
    const threeLetterWords = {};
    const wordCount = documents.reduce((acc, doc) => {
      const words = doc.split(/\s+/);
      words.forEach((word) => {
        word = word.replace(/[^a-zA-ZÀ-ÿ'-]/g, "");
        if (this.excluded_words.includes(word)) {
          return;
        }
        if (word.length == 3) {
          if (threeLetterWords[word]) {
            threeLetterWords[word]++;
          } else {
            threeLetterWords[word] = 1;
          }
        }
        if (word.length < 4) {
          return;
        }
        if (acc[word]) {
          acc[word]++;
        } else {
          acc[word] = 1;
        }
      });
      return acc;
    }, {});
    const sortedThreeLetterWords = Object.keys(threeLetterWords).sort((a, b) => threeLetterWords[b] - threeLetterWords[a]);
    this.excluded_shortcuts.push(...sortedThreeLetterWords.slice(0, 15));
    const sortedFilteredWords = Object.keys(wordCount).sort((a, b) => wordCount[b] - wordCount[a]);
    this.top_words = sortedFilteredWords.slice(0, 100).reduce((acc, word) => {
      acc[word] = wordCount[word];
      return acc;
    }, {});
  }
};

// src/settings/settings.ts
var DEFAULT_SHORTCUTS_DISPLAYED = 10;
var DEFAULT_SHORTCUTS_INCREMENT = 5;
var DEFAULT_SHORTCUTS_GROUP = "Words";
var EnhancedSymbolsPrettifierSettingsTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.shortcutsToDisplay = {};
    this.shortcutsDisplayed = DEFAULT_SHORTCUTS_DISPLAYED;
    this.plugin = plugin;
  }
  displayReplacement(replacement, i, containerEl) {
    const value = replacement.value;
    let key = replacement.replaced;
    new import_obsidian.Setting(containerEl).setName(`${i}.`).setDesc(
      `${replacement.count ? "Triggered " + replacement.count + " time" + (replacement.count > 1 ? "s" : "") : ""}`
    ).addText(
      (text) => text.setPlaceholder("To replace").setValue(key).onChange((index) => __async(this, null, function* () {
        this.plugin.settings.replacements[key].replaced = index;
        this.plugin.settings.replacements[index] = this.plugin.settings.replacements[key];
        delete this.plugin.settings.replacements[key];
        key = index;
        yield this.plugin.saveSettings();
      }))
    ).addText(
      (text) => text.setPlaceholder("Replace with").setValue(value).onChange((val) => __async(this, null, function* () {
        this.plugin.settings.replacements[key].value = val;
        yield this.plugin.saveSettings();
      }))
    ).addToggle(
      (toggle) => toggle.setValue(!replacement.disabled).onChange((value2) => __async(this, null, function* () {
        this.plugin.settings.replacements[key].disabled = !value2;
        yield this.plugin.saveSettings();
      }))
    ).addButton(
      (button) => button.setIcon("x").onClick(() => __async(this, null, function* () {
        delete this.plugin.settings.replacements[key];
        yield this.plugin.saveSettings();
        this.display();
      }))
    );
  }
  displayGroup(group, containerEl) {
    new import_obsidian.Setting(containerEl).setName(group).setHeading();
    new import_obsidian.Setting(containerEl).setName("Disable group").addToggle(
      (toggle) => toggle.setValue(
        Object.values(this.plugin.settings.replacements).filter((replacement) => replacement.group === group).filter((replacement) => !replacement.disabled).length === 0
      ).onChange((value) => __async(this, null, function* () {
        for (const key in this.plugin.settings.replacements) {
          const replacement = this.plugin.settings.replacements[key];
          if (replacement.group === group) {
            this.plugin.settings.replacements[key].disabled = value;
          }
        }
        yield this.plugin.saveSettings();
        this.display();
      }))
    );
    let i = 0;
    for (const key in this.plugin.settings.replacements) {
      const replacement = this.plugin.settings.replacements[key];
      if (replacement.group === group) {
        i++;
        this.displayReplacement(replacement, i, containerEl);
      }
    }
    new import_obsidian.Setting(containerEl).setName("Add new symbol").addButton(
      (button) => button.setIcon("plus").setCta().onClick(() => __async(this, null, function* () {
        this.plugin.settings.replacements[""] = {
          replaced: "",
          value: "",
          disabled: false,
          group
        };
        yield this.plugin.saveSettings();
        this.display();
      }))
    );
  }
  displayExport(containerEl, groups) {
    const dataMapper = new DataMapper(this.plugin.settings);
    const descr = document.createDocumentFragment();
    descr.append(
      "Share your shortcuts with the community. You can find and share shortcuts files on the ",
      descr.createEl("a", {
        text: "Discussions page",
        href: "https://github.com/noam-sc/obsidian-enhanced-symbols-prettifier/discussions/categories/shortcuts"
      }),
      "."
    );
    new import_obsidian.Setting(containerEl).setName("Share your shortcuts").setDesc(descr).setHeading();
    new import_obsidian.Setting(containerEl).setName("Import shortcuts from file").setDesc(
      "Import additional shortcuts from a JSON export file. Any conflicting existing shortcuts will be overridden."
    ).addButton(
      (button) => button.setButtonText("Import").setCta().onClick(() => __async(this, null, function* () {
        const input = document.createElement("input");
        input.type = "file";
        input.accept = ".json";
        input.onchange = () => __async(this, null, function* () {
          if (input.files && input.files.length > 0) {
            const file = input.files[0];
            const reader = new FileReader();
            reader.onload = () => __async(this, null, function* () {
              let data = {};
              try {
                const text = reader.result;
                data = JSON.parse(text);
              } catch (error) {
                new import_obsidian.Notice("Invalid JSON file");
                return;
              }
              this.plugin.settings.replacements = __spreadValues(__spreadValues({}, this.plugin.settings.replacements), data);
              yield this.plugin.saveSettings();
              this.display();
              new import_obsidian.Notice("Shortcuts imported");
            });
            reader.readAsText(file);
          } else {
            new import_obsidian.Notice("No file selected");
          }
        });
        input.click();
      }))
    );
    let dropdownItem = {};
    new import_obsidian.Setting(containerEl).setName("Export shortcuts").setDesc("Export your shortcuts to a JSON file").addDropdown((dropdown) => {
      dropdown.addOption("all", "All shortcuts");
      for (const group of groups) {
        dropdown.addOption(group, group);
      }
      dropdownItem = dropdown;
    }).addButton(
      (button) => button.setButtonText("Export").setCta().onClick(() => __async(this, null, function* () {
        const group = dropdownItem.getValue();
        dataMapper.exportGroup(group);
      }))
    );
  }
  displaySuggestedShorcut(containerEl, shortcut, value, count) {
    new import_obsidian.Setting(containerEl).setName(`Replace '${shortcut}' with '${value}'`).setDesc(`Found ${count} time${count > 1 ? "s" : ""}`).addText(
      (text) => text.setPlaceholder("To replace").setValue(shortcut).onChange((editedShortcut) => __async(this, null, function* () {
        shortcut = editedShortcut;
      }))
    ).addButton(
      (button) => button.setButtonText("Ignore").onClick(() => __async(this, null, function* () {
        if (!this.plugin.settings.exclusions) {
          this.plugin.settings.exclusions = [];
        }
        this.plugin.settings.exclusions.push(shortcut);
        yield this.plugin.saveSettings();
        this.display();
      }))
    ).addButton(
      (button) => button.setButtonText("Add").setCta().onClick(() => __async(this, null, function* () {
        this.plugin.settings.replacements[shortcut] = {
          replaced: shortcut,
          value,
          disabled: false,
          group: DEFAULT_SHORTCUTS_GROUP
        };
        yield this.plugin.saveSettings();
        this.display();
        new import_obsidian.Notice("Shortcut added");
      }))
    );
  }
  displayFinder(containerEl) {
    const excluded_shortcuts = [...this.plugin.settings.exclusions || []];
    for (const key in this.plugin.settings.replacements) {
      const replacement = this.plugin.settings.replacements[key];
      excluded_shortcuts.push(replacement.replaced);
    }
    const excluded_words = Object.keys(
      this.plugin.settings.replacements
    ).map((key) => this.plugin.settings.replacements[key].value);
    const shortcutsFinder = new ShortcutsFinder(
      this.plugin,
      excluded_shortcuts,
      excluded_words
    );
    new import_obsidian.Setting(containerEl).setName("Find most used words").setDesc(
      "Find the most used words in your notes to create shorcuts for them. This operation may take a while depending on the number of notes in your vault."
    ).addButton(
      (button) => button.setIcon("file-search").setCta().onClick(() => __async(this, null, function* () {
        this.shortcutsDisplayed = DEFAULT_SHORTCUTS_DISPLAYED;
        button.setDisabled(true);
        const shortcuts = yield shortcutsFinder.findShortcuts();
        this.shortcutsToDisplay = shortcuts;
        this.display();
        new import_obsidian.Notice("End of search");
      }))
    );
    if (Object.keys(this.shortcutsToDisplay).length > 0) {
      new import_obsidian.Setting(containerEl).setName("Suggested shortcuts").setDesc(
        "Here are the most used words in your notes. You can add them as shortcuts with the suggested one or customize them."
      ).setHeading();
      let counter = 0;
      for (const shortcut in this.shortcutsToDisplay) {
        if (this.plugin.settings.exclusions && this.plugin.settings.exclusions.includes(shortcut)) {
          continue;
        }
        const shortcutItem = this.shortcutsToDisplay[shortcut];
        const replacement = Object.keys(shortcutItem)[0];
        const count = shortcutItem[replacement];
        this.displaySuggestedShorcut(
          containerEl,
          shortcut,
          replacement,
          count
        );
        counter++;
        if (counter === this.shortcutsDisplayed) {
          break;
        }
      }
      if (Object.keys(this.shortcutsToDisplay).length > this.shortcutsDisplayed) {
        new import_obsidian.Setting(containerEl).setName("Show more shortcuts").addButton(
          (button) => button.setButtonText("Show more").onClick(() => {
            this.shortcutsDisplayed += DEFAULT_SHORTCUTS_INCREMENT;
            this.display();
          })
        );
      }
    }
  }
  displayBehaviorSection(containerEl) {
    new import_obsidian.Setting(containerEl).setName("Behavior settings").setHeading();
    new import_obsidian.Setting(containerEl).setName("Flexible start word boundaries").setDesc(
      "Loosen the word boundary detection by allowing symbols or punctuation (like quotes, commas, or parentheses) before a word."
    ).addToggle(
      (toggle) => {
        var _a;
        return toggle.setValue((_a = this.plugin.settings.flexibleWordsStart) != null ? _a : DEFAULT_SETTINGS.flexibleWordsStart).onChange((value) => __async(this, null, function* () {
          this.plugin.settings.flexibleWordsStart = value;
          yield this.plugin.saveSettings();
        }));
      }
    );
    new import_obsidian.Setting(containerEl).setName("Flexible end word boundaries").setDesc(
      "Allow punctuation or symbols immediately after a word to be part of the word boundary, enabling substitutions even when the word isn't followed by a space."
    ).addToggle(
      (toggle) => {
        var _a;
        return toggle.setValue((_a = this.plugin.settings.flexibleWordsEnd) != null ? _a : DEFAULT_SETTINGS.flexibleWordsEnd).onChange((value) => __async(this, null, function* () {
          this.plugin.settings.flexibleWordsEnd = value;
          yield this.plugin.saveSettings();
        }));
      }
    );
  }
  displayReset(containerEl) {
    new import_obsidian.Setting(containerEl).setName("Reset or restore settings").setHeading();
    new import_obsidian.Setting(containerEl).setName("Reset statistics").addButton(
      (button) => button.setIcon("trash").setWarning().onClick(() => __async(this, null, function* () {
        for (const key in this.plugin.settings.replacements) {
          delete this.plugin.settings.replacements[key].count;
        }
        yield this.plugin.saveSettings();
        this.display();
      }))
    );
    new import_obsidian.Setting(containerEl).setName("Restore settings to default").addButton(
      (button) => button.setIcon("archive-restore").setWarning().onClick(() => __async(this, null, function* () {
        yield this.plugin.restoreDefaultSettings();
        this.display();
      }))
    );
    new import_obsidian.Setting(containerEl).setName("Empty ignored shortcuts").setDesc(
      "Remove all ignored shortcuts from the find most used shortcuts feature."
    ).addButton(
      (button) => button.setIcon("trash").setWarning().onClick(() => __async(this, null, function* () {
        this.plugin.settings.exclusions = [];
        yield this.plugin.saveSettings();
        this.display();
      }))
    );
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    this.displayBehaviorSection(containerEl);
    this.displayFinder(containerEl);
    const groups = /* @__PURE__ */ new Set();
    for (const key in this.plugin.settings.replacements) {
      const replacement = this.plugin.settings.replacements[key];
      groups.add(replacement.group);
    }
    this.displayExport(containerEl, groups);
    containerEl.createEl("hr");
    new import_obsidian.Setting(containerEl).setName("Shortcuts").setDesc(
      "Define your shortcuts here : add or remove symbols to prettify in your notes. You can also temporarily disable a symbol by toggling the switch."
    ).setHeading();
    for (const group of groups) {
      this.displayGroup(group, containerEl);
    }
    containerEl.createEl("hr");
    let textNewGroup = "";
    new import_obsidian.Setting(containerEl).setName("Add new group").addText(
      (text) => text.setPlaceholder("Group name").onChange((value) => __async(this, null, function* () {
        textNewGroup = value;
      }))
    ).addButton(
      (button) => button.setButtonText("Add").setCta().onClick(() => __async(this, null, function* () {
        const groupName = textNewGroup;
        if (groupName) {
          this.plugin.settings.replacements[""] = {
            replaced: "",
            value: "",
            disabled: false,
            group: groupName
          };
          yield this.plugin.saveSettings();
          this.display();
        }
      }))
    );
    containerEl.createEl("hr");
    this.displayReset(containerEl);
    containerEl.createEl("p", {
      text: "Made by Noam Schmitt based on the Symbols Prettifier plugin by Florian Woelki."
    });
  }
};

// src/main.ts
var EnhancedSymbolsPrettifier = class extends import_obsidian2.Plugin {
  constructor() {
    super(...arguments);
    this.lastReplacement = {
      active: false,
      sequence: "",
      from: 0,
      line: 0,
      key: ""
    };
  }
  onload() {
    return __async(this, null, function* () {
      yield this.loadSettings();
      this.addSettingTab(
        new EnhancedSymbolsPrettifierSettingsTab(this.app, this)
      );
      this.addCommand({
        id: "format-symbols",
        name: "Prettify existing symbols in document",
        editorCallback: (editor) => this.prettifyInDocument(editor)
      });
      this.addCommand({
        id: "format-symbols-reverse",
        name: "Unprettify existing symbols in document",
        editorCallback: (editor) => this.prettifyInDocument(editor, true)
      });
      let eventName = "keydown";
      if (import_obsidian2.Platform.isMobileApp) {
        eventName = "keyup";
      }
      this.registerDomEvent(window, eventName, (event) => {
        this.keyDownEvent(event);
      });
    });
  }
  onunload() {
    return __async(this, null, function* () {
      yield this.saveSettings();
    });
  }
  loadSettings() {
    return __async(this, null, function* () {
      this.settings = Object.assign(
        {},
        DEFAULT_SETTINGS,
        yield this.loadData()
      );
      this.settings.replacements = Object.assign(
        {},
        DEFAULT_SETTINGS.replacements,
        this.settings.replacements
      );
      this.validateSettings();
    });
  }
  validateSettings() {
    const keys = Object.keys(this.settings.replacements);
    keys.forEach((key) => {
      const replacement = this.settings.replacements[key];
      if (replacement.replaced !== key) {
        this.settings.replacements[replacement.replaced] = replacement;
        delete this.settings.replacements[key];
      }
    });
  }
  saveSettings() {
    return __async(this, null, function* () {
      this.validateSettings();
      yield this.saveData(this.settings);
    });
  }
  restoreDefaultSettings() {
    return __async(this, null, function* () {
      this.settings = JSON.parse(JSON.stringify(DEFAULT_SETTINGS));
      yield this.saveSettings();
    });
  }
  getRegex(reverse = false) {
    const matchChars = Object.entries(this.settings.replacements).reduce(
      (prev, [key, replacement]) => {
        const curr = reverse ? replacement.value : replacement.replaced;
        if (prev.length === 0) {
          return prev + this.escapeRegExp(curr);
        } else if (curr.length === 0 || replacement.disabled) {
          return prev;
        }
        return prev + "|" + this.escapeRegExp(curr);
      },
      ""
    );
    return new RegExp(
      "(?<![\\w\xC0-\xD6\xD8-\xF6\xF8-\xFF])(" + matchChars + ")(?![\\w\xC0-\xD6\xD8-\xF6\xF8-\xFF])"
    );
  }
  prettifyInDocument(editor, reverse = false) {
    let value = editor.getValue();
    const codeBlocks = this.getCodeBlocks(value);
    let matchedChars = [];
    const searchCursor = new SearchCursor(value, this.getRegex(reverse), 0);
    while (searchCursor.findNext() !== void 0) {
      matchedChars.push({
        from: searchCursor.from(),
        to: searchCursor.to()
      });
    }
    matchedChars = matchedChars.filter((matchedChar) => {
      return !codeBlocks.some(
        (cb) => cb.from <= matchedChar.from && cb.to >= matchedChar.to
      );
    });
    let diff = 0;
    let replacementsCount = 0;
    matchedChars.forEach((matchedChar) => {
      var _a;
      const symbol = value.substring(
        matchedChar.from - diff,
        matchedChar.to - diff
      );
      let replacement;
      if (reverse) {
        replacement = (_a = Object.entries(this.settings.replacements).find(
          ([, replacement2]) => replacement2.value === symbol
        )) == null ? void 0 : _a[1];
      } else {
        replacement = this.settings.replacements[symbol];
      }
      if (!replacement) {
        return;
      }
      if (replacement.disabled) {
        return;
      }
      const character = reverse ? replacement.replaced : replacement.value;
      value = value.substring(0, matchedChar.from - diff) + character + value.substring(matchedChar.to - diff);
      diff += symbol.length - character.length;
      replacementsCount++;
      replacement.count = replacement.count ? replacement.count + 1 : 1;
    });
    editor.setValue(value);
    this.saveSettings();
    if (replacementsCount === 0) {
      new import_obsidian2.Notice("No symbols found to replace");
    } else if (replacementsCount === 1) {
      new import_obsidian2.Notice("Replaced 1 symbol");
    } else {
      new import_obsidian2.Notice(`Replaced ${replacementsCount} symbols`);
    }
  }
  applyReplacement(editor, cursor, from, replaceCharacter) {
    const tableCell = editor.editorComponent.tableCell;
    if (tableCell) {
      const editorView = tableCell.cm;
      if (editorView) {
        const cursorPosition = editorView.state.selection.main.head - (import_obsidian2.Platform.isMobileApp ? 1 : 0);
        const fromPosition = cursorPosition - (cursor.ch - from);
        const toPosition = cursorPosition;
        editorView.dispatch({
          changes: {
            from: fromPosition,
            to: toPosition,
            insert: replaceCharacter
          }
        });
      }
    } else {
      editor.replaceRange(
        replaceCharacter,
        { line: cursor.line, ch: from },
        { line: cursor.line, ch: cursor.ch }
      );
    }
  }
  keyDownEvent(event) {
    var _a;
    const lastReplacementTemp = __spreadValues({}, this.lastReplacement);
    this.lastReplacement.active = false;
    const editor = (_a = this.app.workspace.activeEditor) == null ? void 0 : _a.editor;
    if (!editor)
      return;
    const cursor = editor.getCursor();
    if (event.key === "Enter") {
      cursor.line = cursor.line - 1;
      cursor.ch = editor.getLine(cursor.line).length;
    }
    const line = editor.getLine(cursor.line);
    let isSpacebar = false;
    if (import_obsidian2.Platform.isMobileApp) {
      isSpacebar = line.charAt(cursor.ch - 1) === " ";
      cursor.ch = cursor.ch - 1;
    }
    if (this.isWordEnd(event, isSpacebar)) {
      let from = -1;
      let sequence = "";
      for (let i = cursor.ch - 1; i >= 0; i--) {
        if (this.isWordStart(line, i)) {
          const excludeWordStartIndex = i + 1;
          from = excludeWordStartIndex;
          sequence = line.slice(excludeWordStartIndex, cursor.ch);
          if (this.settings.replacements[sequence] && !this.settings.replacements[sequence].disabled || this.isSpaceCharacter(line, i)) {
            break;
          } else if (i === 0) {
            from = i;
            sequence = line.slice(i, cursor.ch);
            break;
          }
        } else if (i === 0) {
          from = i;
          sequence = line.slice(i, cursor.ch);
          break;
        }
      }
      const replacement = this.settings.replacements[sequence];
      if (!replacement) {
        return;
      }
      if (replacement.disabled) {
        return;
      }
      const replaceCharacter = replacement.value;
      if (replaceCharacter && sequence.length > 0 && from !== -1 && !this.isCursorInUnwantedBlocks(editor)) {
        this.applyReplacement(
          editor,
          cursor,
          from,
          replaceCharacter
        );
        this.lastReplacement = {
          active: true,
          sequence,
          from,
          line: cursor.line,
          key: event.key
        };
        replacement.count = replacement.count ? replacement.count + 1 : 1;
        this.saveSettings();
      }
    } else if (event.key === "Backspace" || event.key === "Delete" && import_obsidian2.Platform.isMacOS) {
      if (!lastReplacementTemp.active)
        return;
      const replacement = this.settings.replacements[lastReplacementTemp.sequence];
      if (!replacement || replacement.disabled)
        return;
      const isCursorValid = cursor.line === lastReplacementTemp.line && lastReplacementTemp.from === cursor.ch - replacement.value.length;
      if (!isCursorValid)
        return;
      const lastCharacter = lastReplacementTemp.key;
      let replaceCharacter = replacement.replaced;
      if (lastCharacter == "Enter") {
        replaceCharacter += "\n";
      } else {
        replaceCharacter += lastCharacter;
      }
      this.applyReplacement(
        editor,
        cursor,
        lastReplacementTemp.from,
        replaceCharacter
      );
      this.lastReplacement.active = false;
      this.saveSettings();
    }
  }
  isWordStart(line, i) {
    return this.isSpaceCharacter(line, i) || this.settings.flexibleWordsStart && FLEXIBLE_WORDS_START.includes(line.charAt(i));
  }
  isSpaceCharacter(line, i) {
    return line.charAt(i) === " ";
  }
  isWordEnd(event, isSpacebar) {
    return event.key === " " || isSpacebar || this.settings.flexibleWordsEnd && FLEXIBLE_WORDS_END.includes(event.key);
  }
  escapeRegExp(string) {
    return string.replace(/[.*+?^!${}()|[<>\]\\]/g, "\\$&");
  }
  getCodeBlocks(input) {
    const result = [];
    const codeBlock = /```\w*[^`]+```/;
    const searchCursor = new SearchCursor(input, codeBlock, 0);
    while (searchCursor.findNext() !== void 0) {
      result.push({ from: searchCursor.from(), to: searchCursor.to() });
    }
    return result;
  }
  isCursorInUnwantedBlocks(editor) {
    const unwantedBlocks = [
      /(^|[^`])(`[^`\n]+`)([^`]|$)/,
      /```\w*\s*[\s\S]*?```/,
      /\$(?:[^$\\]|\\.)+\$/
    ];
    return unwantedBlocks.filter((unwantedBlock) => {
      const searchCursor = new SearchCursor(
        editor.getValue(),
        unwantedBlock,
        0
      );
      while (searchCursor.findNext() !== void 0) {
        const offset = editor.posToOffset(editor.getCursor());
        if (searchCursor.from() <= offset && searchCursor.to() >= offset) {
          return true;
        }
      }
      return false;
    }).length !== 0;
  }
};

/* nosourcemap */