/*
THIS IS A GENERATED/BUNDLED FILE BY ROLLUP
if you want to view the source visit the plugins github repository
*/

'use strict';

var obsidian = require('obsidian');

/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */

function __awaiter(thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}

const PLUGIN_NAME = "Multi-line Formatting";
const DEFAULT_SETTINGS = {
    styleArray: [
        {
            id: "multi-line-format-cyan-highlight",
            nickname: "Cyan Highlighter, even over multiple lines",
            leftStyle: '<span style="background-color:#00FEFE">',
            rightStyle: "</span>",
            skipHeadings: false,
            skipListItems: false,
            skipBlockquotes: false,
            formatWord: false,
        },
        {
            id: "multi-line-format-bold",
            nickname: "Bold, even over multiple lines",
            leftStyle: "**",
            rightStyle: "**",
            skipHeadings: false,
            skipListItems: false,
            skipBlockquotes: false,
            formatWord: false,
        },
    ],
};
const NEW_STYLE_DEFAULTS = {
    id: "",
    nickname: "Empty format",
    leftStyle: "",
    rightStyle: "",
    skipHeadings: false,
    skipListItems: false,
    skipBlockquotes: false,
    formatWord: false,
};
class MultilineFormattingPlugin extends obsidian.Plugin {
    onload() {
        return __awaiter(this, void 0, void 0, function* () {
            console.log("Loading " + PLUGIN_NAME + " Plugin");
            yield this.loadSettings();
            for (const style of this.settings.styleArray) {
                this.addStyleCommand(style);
            }
            this.addSettingTab(new MultilineFormattingSettingTab(this.app, this));
        });
    }
    onunload() {
        console.log("Unloading " + PLUGIN_NAME + "Plugin");
    }
    formatSelection(editor, view, style) {
        const cache = this.app.metadataCache.getCache(view.file.path);
        const sections = cache.sections;
        const formatter = new Formatter(style);
        formatter.formatSelection(editor, sections);
    }
    loadSettings() {
        return __awaiter(this, void 0, void 0, function* () {
            this.settings = Object.assign({}, DEFAULT_SETTINGS, yield this.loadData());
        });
    }
    saveSettings() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.saveData(this.settings);
        });
    }
    addStyleCommand(style) {
        this.addCommand({
            id: style.id,
            name: style.nickname,
            editorCallback: (editor, view) => {
                this.formatSelection(editor, view, style);
            },
        });
    }
    addFormattingStyle() {
        const id = String(Math.abs((Date.now() ^ (Math.random() * (1 << 30))) % (1 << 30)));
        const newStyle = Object.assign(Object.assign({}, NEW_STYLE_DEFAULTS), { id: id });
        this.settings.styleArray.push(newStyle);
        this.addStyleCommand(newStyle);
        return newStyle;
    }
    deleteFormattingStyle(style) {
        const index = this.settings.styleArray.indexOf(style);
        if (index >= 0) {
            this.settings.styleArray.splice(index, 1);
        }
        //@ts-ignore
        const appCommands = this.app.commands;
        if (appCommands.findCommand(style.id)) {
            delete appCommands.editorCommands[style.id];
            delete appCommands.commands[style.id];
        }
    }
}
function sectionBinarySearch(line, sections) {
    let low = 0;
    let high = -1;
    if (sections) {
        high = sections.length;
    }
    while (low < high) {
        const midpoint = low + ((high - low) >> 1);
        const midposition = sections[midpoint].position;
        if (line < midposition.start.line) {
            /* cursor before middle section */
            high = midpoint;
        }
        else if (line <= midposition.end.line) {
            /* cursor in middle section */
            return midpoint;
        }
        else {
            /* cursor after middle section */
            low = midpoint + 1;
        }
    }
    /* this might not be the right thing to do. */
    return low;
}
class MultilineFormattingSettingTab extends obsidian.PluginSettingTab {
    constructor(app, plugin) {
        super(app, plugin);
        this.plugin = plugin;
    }
    display() {
        let { containerEl } = this;
        containerEl.empty();
        containerEl.createEl("h2", { text: "Settings for " + PLUGIN_NAME });
        const allStyleDiv = containerEl.createEl("div");
        for (const style of this.plugin.settings.styleArray) {
            const div = this.formattingStyleSetting(style);
            allStyleDiv.appendChild(div);
        }
        new obsidian.Setting(containerEl).addButton((t) => {
            t.setButtonText("Add new formatting style");
            t.onClick((v) => __awaiter(this, void 0, void 0, function* () {
                const newStyle = this.plugin.addFormattingStyle();
                const div = this.formattingStyleSetting(newStyle);
                allStyleDiv.appendChild(div);
            }));
        });
    }
    formattingStyleSetting(style) {
        const containerEl = document.createElement("div");
        const commandheader = containerEl.createEl("h3", {
            text: "Settings for " + style.nickname,
        });
        new obsidian.Setting(containerEl)
            .setName("Nickname")
            .setDesc("The name for your formatting command in the command palette.")
            .addText((text) => text
            // .setPlaceholder('')
            .setValue(style.nickname)
            .onChange((value) => __awaiter(this, void 0, void 0, function* () {
            style.nickname = value;
            commandheader.setText("Settings for " + style.nickname);
            this.plugin.addStyleCommand(style);
            yield this.plugin.saveSettings();
        })));
        new obsidian.Setting(containerEl)
            .setName("Left")
            .setDesc("The opening tag, or the left part of a highlight (==), bold (**), etc.")
            .addTextArea((text) => text
            .setPlaceholder("")
            .setValue(style.leftStyle)
            .onChange((value) => __awaiter(this, void 0, void 0, function* () {
            style.leftStyle = value;
            yield this.plugin.saveSettings();
        })));
        new obsidian.Setting(containerEl)
            .setName("Right")
            .setDesc("The closing tag, or the right part of a highlight (==), bold (**), etc.")
            .addTextArea((text) => text
            .setPlaceholder("")
            .setValue(style.rightStyle)
            .onChange((value) => __awaiter(this, void 0, void 0, function* () {
            style.rightStyle = value;
            yield this.plugin.saveSettings();
        })));
        // const skipDetails: HTMLDetailsElement = containerEl.createEl("details");
        // skipDetails.createEl("summary", { text: "Skip some section types" });
        // new Setting(skipDetails)
        //   .setName('Skip List Items')
        //   .setDesc('Turn this toggle ON to exclude text in list items.')
        //   .addToggle((t) => {
        //     t.setValue(style.skipListItems);
        //     t.onChange(async (v) => {
        //       style.skipListItems = v;
        //       await this.plugin.saveSettings();
        //     })
        //   });
        new obsidian.Setting(containerEl)
            .setName("Skip Headings")
            .setDesc("Turn this toggle ON to exclude text in headings.")
            .addToggle((t) => {
            t.setValue(style.skipHeadings);
            t.onChange((v) => __awaiter(this, void 0, void 0, function* () {
                style.skipHeadings = v;
                yield this.plugin.saveSettings();
            }));
        });
        new obsidian.Setting(containerEl)
            .setName("Format word if selection is empty")
            .setDesc("Turn this toggle ON if you want the command to format the word that the cursor is touching when nothing is selected.")
            .addToggle((t) => {
            t.setValue(style.formatWord);
            t.onChange((v) => __awaiter(this, void 0, void 0, function* () {
                style.formatWord = v;
                yield this.plugin.saveSettings();
            }));
        });
        // new Setting(skipDetails)
        //     .setName('Skip Blockquotes')
        //     .setDesc('Turn this toggle ON to exclude text in blockquotes.')
        //     .addToggle((t) => {
        //       t.setValue(style.skipBlockquotes);
        //       t.onChange(async (v) => {
        //         style.skipBlockquotes = v;
        //         await this.plugin.saveSettings();
        //       })
        //     });
        new obsidian.Setting(containerEl).addButton((t) => {
            t.setButtonText("Delete this style");
            t.onClick((v) => __awaiter(this, void 0, void 0, function* () {
                var _a;
                if (confirm("Are you sure you want to delete " + style.nickname + "?")) {
                    (_a = containerEl.parentElement) === null || _a === void 0 ? void 0 : _a.removeChild(containerEl);
                    this.plugin.deleteFormattingStyle(style);
                }
            }));
        });
        return containerEl;
    }
}
const HEADING_REGEX = /^(?<prefix>\s*#{1,6}\s+)(?<remainder>.*)$/;
const BLOCKQUOTE_REGEX = /^(?<prefix>\s*>\s*)(?<remainder>.*)$/;
const LIST_REGEX = /^(?<prefix>\s*(\*|\+|-|\d+\.|\d+\))\s+(\[.\]\s+)?)(?<remainder>.*)$/;
const LEFT_TRIM_REGEX = /^(?<prefix>\s*)(?<remainder>.*)$/;
const WHITESPACE_ONLY_REGEX = /^\s*$/;
class Formatter {
    constructor(style) {
        this.replacement = [];
        this.style = style;
        this.lastNonEmptyIndex = -1;
        this.isPrecededByParagraphBreak = true;
        this.previousBlockquoteLevel = 0;
        this.blockquoteLevelSoFar = 0;
    }
    formatSelection(doc, sections) {
        const start = doc.getCursor("from");
        const end = doc.getCursor("to");
        if (start.ch == end.ch && start.line == end.line) {
            const line = doc.getLine(end.line);
            if (!this.style.formatWord) {
                doc.replaceSelection(this.style.leftStyle + this.style.rightStyle);
                doc.setCursor(start.line, start.ch + this.style.leftStyle.length);
                return;
            }
            else {
                const left = line.substring(0, end.ch).match(/\S*$/);
                const right = line.substring(end.ch).match(/^\S*/);
                const replacementLine = line.substring(0, left["index"]) +
                    this.style.leftStyle +
                    left[0] +
                    right[0] +
                    this.style.rightStyle +
                    line.substring(end.ch + right[0].length);
                doc.setLine(end.line, replacementLine);
                doc.setCursor(end.line, end.ch + this.style.leftStyle.length);
            }
        }
        for (let lineNum = start.line; lineNum <= end.line; lineNum++) {
            const line = doc.getLine(lineNum);
            this.blockquoteLevelSoFar = 0;
            const startCol = lineNum == start.line ? start.ch : 0;
            const endCol = lineNum == end.line ? end.ch : line.length;
            const parsedLineType = getLineType(line);
            if (sections) {
                const currentSectionIndex = sectionBinarySearch(lineNum, sections);
                if (sections[currentSectionIndex].type == "code") {
                    parsedLineType.desc = "code";
                }
            }
            this.replacement.push(this.processLine(line, startCol, endCol, parsedLineType));
        }
        this.applyRightAbove();
        doc.replaceSelection(this.getReplacement());
    }
    getReplacement() {
        return this.replacement.join("\n");
    }
    processRemainder(remainder, startCh, endCh) {
        const lineType = getLineType(remainder);
        return this.processLine(remainder, startCh, endCh, lineType);
    }
    processLine(line, startCol, endCol, lineType) {
        const { desc, prefix, remainder } = lineType;
        if (desc === "blockquote") {
            this.blockquoteLevelSoFar += 1;
        }
        if (desc === "code") {
            return line.substring(startCol, endCol);
        }
        return (prefix.substring(startCol, endCol) +
            this[desc](remainder, startCol - prefix.length, endCol - prefix.length));
    }
    blockquote(remainder, startCh, endCh) {
        console.debug("bq-level:", this.blockquoteLevelSoFar, "previous:", this.previousBlockquoteLevel);
        if (this.previousBlockquoteLevel < this.blockquoteLevelSoFar) {
            this.isPrecededByParagraphBreak = true;
            this.applyRightAbove();
            this.previousBlockquoteLevel = this.blockquoteLevelSoFar;
        }
        return this.processRemainder(remainder, startCh, endCh);
    }
    heading(remainder, startCh, endCh) {
        const selectedRemainder = remainder.substring(startCh, endCh);
        console.debug("This is a heading");
        this.applyRightAbove();
        this.isPrecededByParagraphBreak = true;
        if (selectedRemainder.search(WHITESPACE_ONLY_REGEX) >= 0 ||
            this.style.skipHeadings) {
            return selectedRemainder;
        }
        else {
            this.setCurrentLineNonEmpty();
            return this.style.leftStyle + selectedRemainder;
        }
    }
    list(remainder, startCh, endCh) {
        this.isPrecededByParagraphBreak = true;
        return this.processRemainder(remainder, startCh, endCh);
    }
    paragraph(remainder, startCh, endCh) {
        if (remainder == "") {
            this.isPrecededByParagraphBreak = true;
            this.previousBlockquoteLevel = this.blockquoteLevelSoFar;
            return remainder;
        }
        else if (remainder.substring(startCh, endCh).search(WHITESPACE_ONLY_REGEX) >= 0) {
            return remainder.substring(startCh, endCh);
        }
        else {
            let returnable;
            if (this.isPrecededByParagraphBreak) {
                this.isPrecededByParagraphBreak = false;
                this.applyRightAbove();
                returnable = this.style.leftStyle + remainder.substring(startCh, endCh);
            }
            else {
                returnable = remainder.substring(startCh, endCh);
            }
            this.setCurrentLineNonEmpty();
            return returnable;
        }
    }
    setCurrentLineNonEmpty() {
        this.lastNonEmptyIndex = this.replacement.length;
    }
    applyRightAbove() {
        if (this.lastNonEmptyIndex >= 0 && this.replacement.length > 0) {
            const [, rightTrimmed, endWhitespace] = this.replacement[this.lastNonEmptyIndex].match(/^(.*?)(\s*)$/);
            this.replacement[this.lastNonEmptyIndex] =
                rightTrimmed + this.style.rightStyle + endWhitespace;
            this.lastNonEmptyIndex = -1;
            return true;
        }
        else
            return false;
    }
}
function getLineType(line) {
    const headingMatch = line.match(HEADING_REGEX);
    if (headingMatch != null) {
        console.debug("HeadingMatch:", headingMatch);
        const { prefix, remainder } = headingMatch.groups;
        return { desc: "heading", prefix, remainder };
    }
    const listMatch = line.match(LIST_REGEX);
    if (listMatch != null) {
        const { prefix, remainder } = listMatch.groups;
        return { desc: "list", prefix, remainder };
    }
    const blockquoteMatch = line.match(BLOCKQUOTE_REGEX);
    if (blockquoteMatch != null) {
        const { prefix, remainder } = blockquoteMatch.groups;
        return { desc: "blockquote", prefix, remainder };
    }
    const { prefix, remainder } = line.match(LEFT_TRIM_REGEX).groups;
    return { desc: "paragraph", prefix, remainder };
}

module.exports = MultilineFormattingPlugin;


/* nosourcemap */